{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Documentation Programme Algo Avanc\u00e9e - M3103 - CHIGNARD Julien Le Programme Le programme consiste en un programme de comptage du nombre d'occurences des mots dans un fichier texte. En l'occurence le fichier texte utilis\u00e9 sera Voyage au centre de la Terre , de Jules Verne. Ce programme s'appuiera sur l'utilisation de table de hachage gr\u00e2ce \u00e0 la librairie unordered_map . Le programme permet de lister tous les diff\u00e9rents mots contenus dans ce document texte ainsi que leurs occurences respectives. Dans un premier temps, il est possible de rechercher un mot dans le livre et d'en conna\u00eetre le nombre d'occurences. Il est ensuite possible de tester les performances de la table de hachage. Ceci est fait en calculant le temps mis pour ins\u00e9rer et rechercher un mot dans des tables de tailles variables gr\u00e2ce \u00e0 la librairie chrono . Mis en rapport avec le taux de charge de la table, on peut se rendre compte des moments ou une insertion \u00e0 n\u00e9c\u00e9ssit\u00e9 une expansion de la table. L'\u00e9volution des temps d'insertion aisi que des temps de recherche nous servent \u00e0 montrer la complexit\u00e9 de la table de hachage utilis\u00e9e, qui est de O(1) dans les deux cas (\u00e0 l'exception des insertions demandant des r\u00e9allocations quand c'est n\u00e9c\u00e9ssaire). Build Tapez simplement make et le Makefile se chargera du reste.","title":"Introduction"},{"location":"#introduction","text":"Documentation Programme Algo Avanc\u00e9e - M3103 - CHIGNARD Julien","title":" Introduction"},{"location":"#le-programme","text":"Le programme consiste en un programme de comptage du nombre d'occurences des mots dans un fichier texte. En l'occurence le fichier texte utilis\u00e9 sera Voyage au centre de la Terre , de Jules Verne. Ce programme s'appuiera sur l'utilisation de table de hachage gr\u00e2ce \u00e0 la librairie unordered_map . Le programme permet de lister tous les diff\u00e9rents mots contenus dans ce document texte ainsi que leurs occurences respectives. Dans un premier temps, il est possible de rechercher un mot dans le livre et d'en conna\u00eetre le nombre d'occurences. Il est ensuite possible de tester les performances de la table de hachage. Ceci est fait en calculant le temps mis pour ins\u00e9rer et rechercher un mot dans des tables de tailles variables gr\u00e2ce \u00e0 la librairie chrono . Mis en rapport avec le taux de charge de la table, on peut se rendre compte des moments ou une insertion \u00e0 n\u00e9c\u00e9ssit\u00e9 une expansion de la table. L'\u00e9volution des temps d'insertion aisi que des temps de recherche nous servent \u00e0 montrer la complexit\u00e9 de la table de hachage utilis\u00e9e, qui est de O(1) dans les deux cas (\u00e0 l'exception des insertions demandant des r\u00e9allocations quand c'est n\u00e9c\u00e9ssaire).","title":"Le Programme"},{"location":"#build","text":"Tapez simplement make et le Makefile se chargera du reste.","title":"Build"},{"location":"code/","text":"Code Ici vous pourrez voir et t\u00e9l\u00e9charger le code en entier. T\u00e9l\u00e9chargement Vous pourrez t\u00e9l\u00e9charger le fichier en cliquant Ici Code #include unordered_map #include iostream #include fstream #include cstring #include chrono #include getopt.h #include vector #include stdlib.h #include math.h #include stdio.h int main(int argc, char * argv[]){ uint maxfind = 1000; uint maxinsert = 1000; uint maxfindall = 300; uint maxinsertall = 300; int options; bool mode = 0; bool datamode = 0; int pas = 1; int mininsert = 10; int minfind = 10; uint iterations = 10; std::vector std::string livre; std::string writefic = \"occurences.txt\"; std::string motcherche = \"\"; std::string ficdatainsert = \"datainsert.dat\"; std::string ficdatafind = \"datafind.dat\"; std::string ficdataload = \"dataload.dat\"; std::string ficdatall = \"data.dat\"; while((options = getopt(argc, argv, \"i:a:z:f:cm:dp:\")) != -1){ switch(options){ case 'i': iterations = std::stoi(optarg); break; case 'a': mininsert = std::stoi(optarg); break; case 'z': maxinsertall = std::stoi(optarg); break; case 'f': writefic = optarg; break; case 'c': mode = true; break; case 'm': motcherche = optarg; break; case 'd': datamode = true; break; case 'p': pas = std::stoi(optarg); break; } } minfind = mininsert; maxfindall = maxinsertall; std::ifstream ifs; std::ofstream ofs; std::ofstream ficinsert, ficfind, ficload, ficall; std::cout \"R\u00e9initialisation du fichier d'occurences...\" std::endl; if( remove(writefic.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); ofs.open(writefic, std::ofstream::out); if(datamode){ std::cout \"R\u00e9initialisation du fichier de temps d'insertion...\" std::endl; if( remove(ficdatainsert.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier de temps de recherche...\" std::endl; if( remove(ficdatafind.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier de taux de charge...\" std::endl; if( remove(ficdataload.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier global de donn\u00e9es...\" std::endl; if( remove(ficdatall.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); ficinsert.open(ficdatainsert, std::ofstream::out); ficfind.open(ficdatafind, std::ofstream::out); ficload.open(ficdataload, std::ofstream::out); ficall.open(ficdatall, std::ofstream::out); ficall \"#Donn\u00e9es de temps d'insertion, de recherche et de taux de charge sur une table de hachage.\" std::endl; ficall \"#Taille_map Insertion Recherche Charge\" std::endl; } ifs.open(\"Jules_Verne_Voyage_au_centre_de_la_Terre.txt\", std::ifstream::in); if(!ifs.is_open()){return 1;} uint nbfind = 0; uint nbinsert = 0; std::chrono::nanoseconds time_find; std::chrono::nanoseconds time_insert; std::string mot; std::unordered_map std::string, int map; if(!mode){ while(ifs mot ifs.good()){ //ifs mot; livre.push_back(mot); std::unordered_map std::string, int ::const_iterator found; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); found = map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); if(nbfind = maxfind){ time_find = time_find + std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); nbfind++; } if(found == map.end()){ std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); map[mot] = 1; std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); if(nbinsert = maxinsert){ time_insert = time_insert + std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); nbinsert++; } } else map[mot]++; } for (auto x: map) ofs x.first \": \" x.second std::endl; if(motcherche != \"\"){ std::unordered_map std::string, int ::const_iterator motch = map.find(motcherche); std::cout \"Nombre de mots diff\u00e9rents : \" map.size() std::endl; if(motch != map.end()) std::cout \"Nombre d'occurences du mot '\" motcherche \"' : \" map[mot] std::endl; else std::cout \"Le mot : '\" motcherche \"' ne figure pas dans le fichier.\" std::endl; } } else{ while(ifs mot ifs.good()) livre.push_back(mot); std::vector std::chrono::nanoseconds tabtempsinsert; std::vector std::chrono::nanoseconds tabtempsfind; std::cout \"Insertion...\" std::endl; for(uint w=mininsert;w =maxinsertall;w=w+pas){ while(map.size() w map.size() livre.size()){ int chosen = std::rand() % livre.size(); mot = livre[chosen]; map[mot]++; } tabtempsfind.clear(); tabtempsinsert.clear(); if(datamode){ maxinsert = w; } else{w = maxinsertall;} time_insert = std::chrono::nanoseconds::zero(); std::unordered_map std::string, int ::const_iterator found; //do{ // On choisit un mot au hasard qui n'est pas dans la table //}while(map.find(mot) != map.end()); tabtempsfind.clear(); for(uint i=1;i =iterations;++i){ int chosen = (std::rand() % livre.size()); mot = livre[chosen]; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); found = map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); std::chrono::nanoseconds time_find = std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); tabtempsfind.push_back(time_find); } time_find = std::chrono::nanoseconds::zero(); for(auto n : tabtempsfind){ //if(n.count() 1500) time_find += n; /*else time_find += std::chrono::nanoseconds(1500);*/ //std::cout \" \" n.count(); } //std::cout std::endl \"temps find : \" time_find.count() \"size : \" tabtempsfind.size() std::endl; double totimefind = time_find.count() / (double)tabtempsfind.size(); //std::cout \"totimefind : \" totimefind std::endl; tabtempsinsert.clear(); for(uint i=1;i =iterations;++i){ int chosen = (std::rand() % livre.size()); mot = livre[chosen]; std::unordered_map std::string, int newmap(map); std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); newmap[mot]++; std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); std::chrono::nanoseconds time_insert = std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); newmap.clear(); tabtempsinsert.push_back(time_insert); } time_insert = std::chrono::nanoseconds::zero(); for(auto n : tabtempsinsert) time_insert += n; double totimeinsert = time_insert.count() / (double)tabtempsinsert.size(); //tabtempsinsert.push_back(time_insert); float progress = (float)(w-mininsert)/(maxinsertall-mininsert); int pos = 60 * progress; std::cout \"[\"; for (int k = 0; k 60; ++k) { if (k pos) std::cout \"#\"; else if (k == pos) std::cout \" \"; else std::cout \" \"; } std::cout \"] \" std::ceil(progress * 100.0) \" % | \" std::ceil((w-mininsert)/pas) \"/\" std::ceil((maxinsertall-mininsert)/pas) \"\\r\"; std::cout.flush(); if(datamode){ ficinsert map.size()-1 \" \" time_insert.count()/100000000 std::endl; ficfind map.size()-1 \" \" (double)time_find.count()/100000000 std::endl; ficload map.size()-1 \" \" map.load_factor() std::endl; ficall map.size()-1 \" \" totimeinsert/100000000 \" \" totimefind/100000000 \" \" map.load_factor() std::endl; } } std::cout std::endl \"Insertion termin\u00e9e.\" std::endl; /* std::cout \"Recherche...\" std::endl; //maxfindall = maxfind + minfind; for(uint i=0;i maxfind;++i){ int chosen = std::rand() % livre.size(); mot = livre[chosen]; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); time_find = time_find + std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); float progress = (float)i/maxfind; //std::cout progress \"i : \" i \"max : \" maxinsert std::endl; int pos = 60 * progress; std::cout \"[\"; for (int k = 0; k 60; ++k) { if (k pos) std::cout \"#\"; else if (k == pos) std::cout \" \"; else std::cout \" \"; } std::cout \"] \" std::ceil(progress * 100.0) \" %\\r\"; std::cout.flush(); } std::cout \"Recherche termin\u00e9e.\" std::endl; }*/ std::cout std::endl map.size() \" mots diff\u00e9rents\" std::endl; std::cout \"Temps d'insertion pour \" maxinsert \" mots : \" time_insert.count() \"ns (\" (double)time_insert.count()/100000000 \"s)\" std::endl; std::cout \"Temps de recherche pour \" maxfind \" mots : \" time_find.count() \"ns (\" (double)time_find.count()/100000000 \"s)\" std::endl; } }","title":"Code"},{"location":"code/#code","text":"Ici vous pourrez voir et t\u00e9l\u00e9charger le code en entier.","title":"Code"},{"location":"code/#telechargement","text":"Vous pourrez t\u00e9l\u00e9charger le fichier en cliquant Ici","title":"T\u00e9l\u00e9chargement"},{"location":"code/#code_1","text":"#include unordered_map #include iostream #include fstream #include cstring #include chrono #include getopt.h #include vector #include stdlib.h #include math.h #include stdio.h int main(int argc, char * argv[]){ uint maxfind = 1000; uint maxinsert = 1000; uint maxfindall = 300; uint maxinsertall = 300; int options; bool mode = 0; bool datamode = 0; int pas = 1; int mininsert = 10; int minfind = 10; uint iterations = 10; std::vector std::string livre; std::string writefic = \"occurences.txt\"; std::string motcherche = \"\"; std::string ficdatainsert = \"datainsert.dat\"; std::string ficdatafind = \"datafind.dat\"; std::string ficdataload = \"dataload.dat\"; std::string ficdatall = \"data.dat\"; while((options = getopt(argc, argv, \"i:a:z:f:cm:dp:\")) != -1){ switch(options){ case 'i': iterations = std::stoi(optarg); break; case 'a': mininsert = std::stoi(optarg); break; case 'z': maxinsertall = std::stoi(optarg); break; case 'f': writefic = optarg; break; case 'c': mode = true; break; case 'm': motcherche = optarg; break; case 'd': datamode = true; break; case 'p': pas = std::stoi(optarg); break; } } minfind = mininsert; maxfindall = maxinsertall; std::ifstream ifs; std::ofstream ofs; std::ofstream ficinsert, ficfind, ficload, ficall; std::cout \"R\u00e9initialisation du fichier d'occurences...\" std::endl; if( remove(writefic.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); ofs.open(writefic, std::ofstream::out); if(datamode){ std::cout \"R\u00e9initialisation du fichier de temps d'insertion...\" std::endl; if( remove(ficdatainsert.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier de temps de recherche...\" std::endl; if( remove(ficdatafind.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier de taux de charge...\" std::endl; if( remove(ficdataload.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); std::cout \"R\u00e9initialisation du fichier global de donn\u00e9es...\" std::endl; if( remove(ficdatall.c_str()) != 0 ) perror( \"Echec de l'op\u00e9ration :/ \" ); else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); ficinsert.open(ficdatainsert, std::ofstream::out); ficfind.open(ficdatafind, std::ofstream::out); ficload.open(ficdataload, std::ofstream::out); ficall.open(ficdatall, std::ofstream::out); ficall \"#Donn\u00e9es de temps d'insertion, de recherche et de taux de charge sur une table de hachage.\" std::endl; ficall \"#Taille_map Insertion Recherche Charge\" std::endl; } ifs.open(\"Jules_Verne_Voyage_au_centre_de_la_Terre.txt\", std::ifstream::in); if(!ifs.is_open()){return 1;} uint nbfind = 0; uint nbinsert = 0; std::chrono::nanoseconds time_find; std::chrono::nanoseconds time_insert; std::string mot; std::unordered_map std::string, int map; if(!mode){ while(ifs mot ifs.good()){ //ifs mot; livre.push_back(mot); std::unordered_map std::string, int ::const_iterator found; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); found = map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); if(nbfind = maxfind){ time_find = time_find + std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); nbfind++; } if(found == map.end()){ std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); map[mot] = 1; std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); if(nbinsert = maxinsert){ time_insert = time_insert + std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); nbinsert++; } } else map[mot]++; } for (auto x: map) ofs x.first \": \" x.second std::endl; if(motcherche != \"\"){ std::unordered_map std::string, int ::const_iterator motch = map.find(motcherche); std::cout \"Nombre de mots diff\u00e9rents : \" map.size() std::endl; if(motch != map.end()) std::cout \"Nombre d'occurences du mot '\" motcherche \"' : \" map[mot] std::endl; else std::cout \"Le mot : '\" motcherche \"' ne figure pas dans le fichier.\" std::endl; } } else{ while(ifs mot ifs.good()) livre.push_back(mot); std::vector std::chrono::nanoseconds tabtempsinsert; std::vector std::chrono::nanoseconds tabtempsfind; std::cout \"Insertion...\" std::endl; for(uint w=mininsert;w =maxinsertall;w=w+pas){ while(map.size() w map.size() livre.size()){ int chosen = std::rand() % livre.size(); mot = livre[chosen]; map[mot]++; } tabtempsfind.clear(); tabtempsinsert.clear(); if(datamode){ maxinsert = w; } else{w = maxinsertall;} time_insert = std::chrono::nanoseconds::zero(); std::unordered_map std::string, int ::const_iterator found; //do{ // On choisit un mot au hasard qui n'est pas dans la table //}while(map.find(mot) != map.end()); tabtempsfind.clear(); for(uint i=1;i =iterations;++i){ int chosen = (std::rand() % livre.size()); mot = livre[chosen]; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); found = map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); std::chrono::nanoseconds time_find = std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); tabtempsfind.push_back(time_find); } time_find = std::chrono::nanoseconds::zero(); for(auto n : tabtempsfind){ //if(n.count() 1500) time_find += n; /*else time_find += std::chrono::nanoseconds(1500);*/ //std::cout \" \" n.count(); } //std::cout std::endl \"temps find : \" time_find.count() \"size : \" tabtempsfind.size() std::endl; double totimefind = time_find.count() / (double)tabtempsfind.size(); //std::cout \"totimefind : \" totimefind std::endl; tabtempsinsert.clear(); for(uint i=1;i =iterations;++i){ int chosen = (std::rand() % livre.size()); mot = livre[chosen]; std::unordered_map std::string, int newmap(map); std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); newmap[mot]++; std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); std::chrono::nanoseconds time_insert = std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); newmap.clear(); tabtempsinsert.push_back(time_insert); } time_insert = std::chrono::nanoseconds::zero(); for(auto n : tabtempsinsert) time_insert += n; double totimeinsert = time_insert.count() / (double)tabtempsinsert.size(); //tabtempsinsert.push_back(time_insert); float progress = (float)(w-mininsert)/(maxinsertall-mininsert); int pos = 60 * progress; std::cout \"[\"; for (int k = 0; k 60; ++k) { if (k pos) std::cout \"#\"; else if (k == pos) std::cout \" \"; else std::cout \" \"; } std::cout \"] \" std::ceil(progress * 100.0) \" % | \" std::ceil((w-mininsert)/pas) \"/\" std::ceil((maxinsertall-mininsert)/pas) \"\\r\"; std::cout.flush(); if(datamode){ ficinsert map.size()-1 \" \" time_insert.count()/100000000 std::endl; ficfind map.size()-1 \" \" (double)time_find.count()/100000000 std::endl; ficload map.size()-1 \" \" map.load_factor() std::endl; ficall map.size()-1 \" \" totimeinsert/100000000 \" \" totimefind/100000000 \" \" map.load_factor() std::endl; } } std::cout std::endl \"Insertion termin\u00e9e.\" std::endl; /* std::cout \"Recherche...\" std::endl; //maxfindall = maxfind + minfind; for(uint i=0;i maxfind;++i){ int chosen = std::rand() % livre.size(); mot = livre[chosen]; std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); map.find(mot); std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); time_find = time_find + std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); float progress = (float)i/maxfind; //std::cout progress \"i : \" i \"max : \" maxinsert std::endl; int pos = 60 * progress; std::cout \"[\"; for (int k = 0; k 60; ++k) { if (k pos) std::cout \"#\"; else if (k == pos) std::cout \" \"; else std::cout \" \"; } std::cout \"] \" std::ceil(progress * 100.0) \" %\\r\"; std::cout.flush(); } std::cout \"Recherche termin\u00e9e.\" std::endl; }*/ std::cout std::endl map.size() \" mots diff\u00e9rents\" std::endl; std::cout \"Temps d'insertion pour \" maxinsert \" mots : \" time_insert.count() \"ns (\" (double)time_insert.count()/100000000 \"s)\" std::endl; std::cout \"Temps de recherche pour \" maxfind \" mots : \" time_find.count() \"ns (\" (double)time_find.count()/100000000 \"s)\" std::endl; } }","title":"Code"},{"location":"fonctionnement/","text":"Fonctionnement Comment le programme fonctionne \u00e9tape par \u00e9tape et les bouts de code correspondants. Commandes options Les options sont g\u00e9r\u00e9e gr\u00e2ce \u00e0 la librairie getopt . La commande de base est la suivante : ./hachageJV , \u00e0 laquelle s'ajoutent plusieurs options que sont les suivantes : -m [mot] - Affiche le nombre d'occurences d'un mot dans le fichier. -c - Mode de calcul des temps, sans cette option le programme se contente de remplir la table de hachage (et d'y rechercher un mot si l'option -m est utilis\u00e9e). -d - Mode d'\u00e9dition de donn\u00e9es. Active l'\u00e9criture des donn\u00e9es de temps sur un fichier .dat quand utilis\u00e9e avec l'option -c. -a [min] - Borne inf\u00e9rieure de la range de taille de table \u00e0 tester. Est fix\u00e9e \u00e0 10 par d\u00e9faut. Doit \u00eatre positive et inf\u00e9rieure \u00e0 la borne sup\u00e9rieure. -z [max] - Borne sup\u00e9rieure de la range de la taille de table \u00e0 tester. Est fix\u00e9e \u00e0 300 par d\u00e9faut. Doit \u00eatre sup\u00e9rieure \u00e0 la borne inf\u00e9rieure et inf\u00e9rieure \u00e0 13 996 (nombre de mots diff\u00e9rents dans Voyage au centre de la Terre). -i [iterations] - Nombre d'it\u00e9rations pour chaque calcul de moyenne de temps. Augmenter ce nombre donnera des r\u00e9sultats plus lisses au prix de la performance. Est fix\u00e9e \u00e0 10 par d\u00e9faut. Doit \u00eatre positive. -p [pas] - Pas pour tester chaque taille de table dans la range indiqu\u00e9e. Est fix\u00e9 \u00e0 1 par d\u00e9faut. Doit \u00eatre positif. -f [fichier] - Permet de choisir le fichier de sortie du nombre d'occurences des mots. Attention ce fichier sera \u00e9cras\u00e9 sans confirmation au d\u00e9but du programme. Est fix\u00e9 \u00e0 'occurences.txt' par d\u00e9faut. Initialisation Apr\u00e8s v\u00e9rification des options et initialisation des diff\u00e9rentes variables, le programme commence par ouvrir le fichier texte pour en compter les occurences des diff\u00e9rents mots : std::ifstream ifs; # D\u00e9claration d'un flux d'entr\u00e9e. ifs.open(ficTexte,std::ifstream::in); # Ouverture du fichier texte \u00e0 analyser en lecture. Ensuite, gr\u00e2ce \u00e0 la librairie vector et pour \u00e9viter des sou\u00e7is de performance, il va nous falloir stocker tout le contenu de ce fichier texte dans une variable. Cette variable sera dans notre cas un vecteur de string (librairie cstring ) : std::vector std::string livre; # Cette d\u00e9claration est en r\u00e9alit\u00e9 faite avant mais cela aide \u00e0 la compr\u00e9hension. while(ifs mot ifs.good()) # Tant que l'on est pas arriv\u00e9 \u00e0 la fin du fichier livre.push_back(mot); # On ajoute chaque mot dans le vecteur. Une fois cela fait, le programme est pr\u00eat \u00e0 fonctionner. I - Nombre d'occurences Le premier mode de fonctionnement de ce programme est le comptage du nombre d'occurences de chaque mot pr\u00e9sent dans le fichier texte et la possibilit\u00e9 de rechercher le nombre d'occurences d'un mot. Voici le fonctionnement de cette partie : Incr\u00e9mentation Il nous faut pour commencer entrer tous les mots dans la table de hachage, on va faire cela en se servant du mot-cl\u00e9 auto : for (auto mot: livre) # Va parcourir tous les index du vecteur de mots. map[mot]++; # On incr\u00e9mente son nombre d'occurrence dans la table de hachage. Les avantages de cette syntaxe sont que auto est plus efficace qu'une simple boucle for en terme de m\u00e9moire, et map[mot]++; couvre aussi bien le cas o\u00f9 le mot est d\u00e9ja pr\u00e9sent dans la table que celui o\u00f9 il ne l'est pas (dans ce cas il cr\u00e9era cette cl\u00e9 et initialisera sa valeur \u00e0 1). Recherche d'un mot Une fois que la table de hachage est remplie, nous pouvons rechercher le nombre d'occurences d'un mot en particulier : std::unordered_map std::string, int ::const_iterator motch; motch= map.find(motcherche); # On regarde si le mot cherch\u00e9 est bien dans la table. if(motch != map.end()) # Si c'est le cas std::cout \"Nombre d'occurences du mot '\" motcherche \"' : \" map[mot] std::endl; # On affiche son nombre d'occurences. else # Sinon std::cout \"Le mot : '\" motcherche \"' ne figure pas dans le fichier.\" std::endl; # On indique qu'il ne figure pas dans la table. Sortie Pour sortir tous les mots et leurs occurences, il faut d'abord vider le fichier pr\u00e9c\u00e9dent d'occurences, pour ne pas provoquer de doublons : # Cette suite dop\u00e9rations est en r\u00e9alit\u00e9 effectu\u00e9e plus t\u00f4t dans l'\u00e9xecution mais cela aide \u00e0 la compr\u00e9hension. std::ofstream ofs; # On cr\u00e9e le flux de sortie. std::cout \"R\u00e9initialisation du fichier d'occurences...\" std::endl; # Pour savoir que la proc\u00e9dure \u00e0 commenc\u00e9e. if( remove(writefic.c_str()) != 0 ) # Suppression du fichier. perror( \"Echec de l'op\u00e9ration :/ \" ); # Erreur else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); # Succ\u00e8s ofs.open(writefic, std::ofstream::out); # On r\u00e9ouvre le fichier en lecture, ce qui \u00e0 pour effet de le recr\u00e9er. Ensuite, il faut bien \u00e9videmment le remplir : for (auto x: map) # Nouvelle utilisation de auto pour parcourir la table de hachage. ofs x.first \": \" x.second std::endl; # On \u00e9crit chaque mot (cl\u00e9) avec son nombre d'occurences (valeur) dans le fichier. II - Calcul de la complexit\u00e9 Le second mode d'utilisation de ce programme est celui qui nous int\u00e9rresse le plus : les temps d'insertion et de recherche. Voici comment tout cela fonctionne : Tailles de la table Le but de ce programme est de pouvoir observer la complexit\u00e9 des temps d'insertion et de recherche, donc de mesurer ces temps pour des tailles de table de hachage variables. Pour ce faire on va dans un premier temps remplir la table jusqu'a la taille minimale de la range entr\u00e9e en param\u00e8tre : while(map.size() mininsert map.size() livre.size()){ # Tant que la taille de la table est inf\u00e9rieure \u00e0 la taille souhait\u00e9e et qu'on a pas entr\u00e9 tout le livre. int chosen = std::rand() % livre.size(); # On tire un chiffre al\u00e9atoire en tre 0 et le nombre de mots du livre. mot = livre[chosen]; # Cela nous donne un mot. map[mot]++; # On ajoute ce mot / incr\u00e9mente son nombre d'occurences. } Ensuite, un fois notre table de hachage initialis\u00e9e \u00e0 la taille minimale voulue, on rentre dans la boucle \"principale\" qui va pour chaque taille de la table voulue dans la range entr\u00e9e en param\u00e8tre (en prenant le pas en compte) calculer le temps d'insertion, le temps de recherche, le taux de charge et \u00e9crire ces valeurs dans le fichier de sortie : for(uint w=mininsert;w =maxinsertall;w=w+pas){ # On va parcourir la range de taille de table voulue en prenant le pas entr\u00e9 en param\u00e8tre comme pas. while(map.size() w map.size() livre.size()){ # On ajuste la taille de la table si n\u00e9cessaire (si pas 1). int chosen = std::rand() % livre.size(); mot = livre[chosen]; map[mot]++; } # Les calculs sont faits i\u00e7i... # Sortie... } Un fois cette boucle r\u00e9alis\u00e9e, nous pouvons nous pencher sur le reste. Temps de recherche Le temps de recherche est calcul\u00e9 avant le temps d'insertion, pour ce faire on va simplement s\u00e9lectionner un mot au hasard dans le livre : int chosen = (std::rand() % livre.size()); # Un index de mot au hasard dans le livre. mot = livre[chosen]; # On extrait le mot s\u00e9lectionn\u00e9. Cela nous permet de pouvoir piocher aussi boen un mot qui existe d\u00e9ja dans la table comme un qui n'y figure pas (pour avoir des r\u00e9sultats refl\u00e9tant la r\u00e9alit\u00e9). On a plus qu'a rechercher ce mot dans la table. cette recherche est effectu\u00e9e gr\u00e2ce \u00e0 la fonction find() de unordered_map . Qui renvoie l'index du mot recherch\u00e9 dans la table si il s'y trouve, et std::unordered_map::end sinon. On initialise donc une variable pour pouvoir stocker ce r\u00e9sultat, bien qu'on ne s'en serve pas par la suite : std::unordered_map std::string, int ::const_iterator found; # Initialisation du conteneur de la sortie du find(). Enfin, pour calculer le temps pris pour cette recherche, nous nous servons de la librairie chrono gr\u00e2ce \u00e0 laquelle nous allons cr\u00e9er 2 time points en nanosecondes : le premier juste avant la recherche et le second juste apr\u00e8s. Nous pouvons ensuite r\u00e9cup\u00e9rer le temps pris pour la recherche gr\u00e2ce \u00e0 la diff\u00e9rence de ces deux time points : std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); # Premier time point T1. found = map.find(mot); # On recherche le mot. std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); # Second time point T2. std::chrono::nanoseconds time_find = std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); # T2 - T1 pour avoir la dur\u00e9e de la recherche. On r\u00e9cup\u00e8re donc le temps pris par la recherche dans la variable time_find , en nanosecondes. Temps d'insertion Comme pour la recherche, le temps d'insertion d\u00e9but par le choix d'un mot au hasard dans le livre : int chosen = (std::rand() % livre.size()); # Un index de mot au hasard dans le livre. mot = livre[chosen]; # On extrait le mot s\u00e9lectionn\u00e9. Ensuite on ins\u00e8re le mot dans la table et on chronom\u00e8tre le temps pris pour cette insertion comme pour le temps de la recherche, gr\u00e2ce \u00e0 2 time points avant et apr\u00e8s l'insertion : std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); # T1 newmap[mot]++; # Insertion std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); # T2 std::chrono::nanoseconds time_insert = std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); # T2 - T1 Taux de charge La mesure du taux de charge est tr\u00e8s importante car elle permet de voir quand la table devient satur\u00e9e et quand les collisions ont le plus de chances d'arriver (cf : Load Factor ). Le Taux de charge est calcul\u00e9 en divisant la taille de la table par le nombre de cl\u00e9s ayant au moins une valeur associ\u00e9e Ce taux de charge est r\u00e9cup\u00e9r\u00e9 gr\u00e2ce \u00e0 la fonction suivante : float tauxCharge = map.load_factor(); # Renvoie un float entre 0 et 1 qui correpond au taux de charge. Moyennes Pour avoir des r\u00e9sultats plus lisses et pour \u00e9viter les erreurs occasionnelles qui pourraient provoquer des pics sur le graphe, on va donc r\u00e9aliser plusieurs fois chaque recherche et chaque insertion et en faire les moyennes. Chaque recherche et chaque insertion sera faite avec des mots diff\u00e9rents car ce n'est pas l'insertion ou la recherche d'un mot en particulier mais bien le comportement de la table pour une taille donn\u00e9e. Pour ce faire on va avoir besoin de 2 vecteurs (librairie vector ) de std::chrono::nanoseconds dans lesquels nous allons stocker respectivement nos temps d'insertion et de recherche. On commence par les initialiser : std::vector std::chrono::nanoseconds tabtempsinsert; # Vecteur des temps d'insertion std::vector std::chrono::nanoseconds tabtempsfind; # Vecteur des temps de recherche Ensuite, il va nous falloir r\u00e9aliser chaque op\u00e9rations plusieurs fois. Ce nombre de fois est param\u00e9tr\u00e9 par l'utilisateur et est stock\u00e9 dans un uint nomm\u00e9 iterations . Exemple pour la recherche : tabtempsfind.clear(); # On vide le vecteur qui a pu \u00eatre rempli par les it\u00e9rations pr\u00e9c\u00e9dentes. for(uint i=1;i =iterations;++i){ # Pour le nombre d'it\u00e9rations d\u00e9fini. # Proc\u00e9dure de recherche et mesure du temps pris... tabtempsfind.push_back(time_find); # On ajoute le temps trouv\u00e9 au vecteur correspondant. } On va ensuite faire la somme de tous les temps contenus dans le vecteur. Par gain de temps et pour nous \u00e9viter des casts \u00e9vitables, on stockera ce temps dans la m\u00eame variable que celle ayant servi \u00e0 mesurer le temps juste avant : time_find = std::chrono::nanoseconds::zero(); # On remet le temps \u00e0 0. for(auto n : tabtempsfind) # Pour chaque index du vecteur. time_find += n; # On incr\u00e9mente la variable de ce temps. Pour avoir une moyenne il nous faut ensuite diviser cette somme par le nombre de temps qu'elle contient, rien de plus simple : double totimefind = time_find.count() / (double)tabtempsfind.size(); # .count() permet de r\u00e9cup\u00e9rer une valeur num\u00e9rique du temps. # Le cast est n\u00e9c\u00e9ssaire pour une division. On r\u00e9cup\u00e8re donc la moyenne des temps de recherche dnas la variable totimefind . (Oui bon j'aurais pu trouver mieux comme nom je sais) Le cas de l'insertion est tr\u00e8s l\u00e9g\u00e9remment diff\u00e9rent, bien que son d\u00e9but soit identique \u00e0 celui de la recherche : tabtempsinsert.clear(); # On vide le vecteur for(uint i=1;i =iterations;++i){ # Pour chaque it\u00e9ration. int chosen = (std::rand() % livre.size()); # On choisit un mot... mot = livre[chosen]; On ne pourra pas simplement ins\u00e9rer plusieurs mots \u00e0 la suite et compter le temps, car la taille de la table va \u00e9voluer sans que l'on le veuille. Pour pallier \u00e0 ce souci, on va devoir pour chaque it\u00e9ration cr\u00e9er une copie de la table de hachage : std::unordered_map std::string, int newmap(map); # Constructeur par copie. La suite est identique \u00e0 la proc\u00e9dure de calcul de temps d'insertion expliqu\u00e9e plus haut \u00e0 cela pr\u00e8s qu'au lieu d'ins\u00e9rer le mot dans la table on l'ins\u00e8re dans la copie de la table : # Time point 1 newmap[mot]++; # Insertion # Time point 2 # time_insert = T2 - T1 tabtempsinsert.push_back(time_insert); # Ajout du temps au vecteur des temps d'insertion. La suite est identique \u00e0 la recherche, en changeant de vecteur utilis\u00e9 evidemment : time_insert = std::chrono::nanoseconds::zero(); # On remet le temps \u00e0 0. for(auto n : tabtempsinsert) #Pour chaque temps dans le vecteur. time_insert += n; #On incr\u00e9mente la variable de ce temps. double totimeinsert = time_insert.count() / (double)tabtempsinsert.size(); # On en fait ensuite la moyenne. On r\u00e9cup\u00e8re la moyenne des temps d'insertion dans la variable totimeinsert . Sortie La sortie se fait dans un fichier data.dat unique constitu\u00e9 de la sorte : Taille table Temps Insertion Temps Recherche Taux de charge 0 2.69e-06 4.20e-07 0.001337 1 1.337e-05 3.86e-06 0.0713705 2 ... ... ... Le fichier \u00e0 \u00e9t\u00e9 initialis\u00e9 comme l'a \u00e9t\u00e9 celui du nombre d'occurences (expliqu\u00e9 plus haut), et est donc vide au d\u00e9but de l'\u00e9criture. Pour \u00e9crire dedans on va simplement s\u00e9parer toutes les donn\u00e9es par un espace : ficall map.size()-1 \" \" totimeinsert/100000000 \" \" totimefind/100000000 \" \" map.load_factor() std::endl; # On divise tous les temps par 100 000 000 pour avoir des secondes. Vous pouvez t\u00e9l\u00e9charger un fichier de donn\u00e9es en cliquant ici Barre de progression Pour se rendre compte de la progression du programme, car son utilisation peut prendre beaucoup de temps, j'ai r\u00e9alis\u00e9 une barre de progression. Elle suit les tailles de table test\u00e9es, on ne sait pas pr\u00e9cisemment \u00e0 quelle it\u00e9ration on en est (pour les moyennes) mais on sait quelle taille de table est test\u00e9e. Voici son fonctionnement : On commence par trouver le pourcentage de progression actuel, qui est pris en utilisant la position actuelle de la boucle ( w ) et en la comparant avec son maximum ( maxinsertall ), auquel on soustrait le point de d\u00e9part ( mininsert ) car sinon une \u00e9tude sur des tailles allant par exemple de 5000 \u00e0 10 000 commen\u00e7erait \u00e0 50% d\u00e8s le d\u00e9but. float progress = (float)(w-mininsert)/(maxinsertall-mininsert); # Progression en pourcentage. int pos = 60 * progress; # On le multiplie par 60 (taille arbitraire de la barre en caract\u00e8res). Vient ensuite la barre en elle-m\u00eame : std::cout \"[\"; # Le cot\u00e9 gauche de la barre, fixe. for (int k = 0; k 60; ++k) { # Pour toute la longueur de la barre. if (k pos) std::cout \"#\"; # Si on est avant la position de la progression, on affiche un \"#\". else if (k == pos) std::cout \" \"; # Si on est exactement \u00e0 cette position, on affiche un \" \". else std::cout \" \"; # Et sinon on affiche un espace (barre vide). } std::cout \"] \" std::ceil(progress * 100.0) \" % | \" std::ceil((w-mininsert)/pas) \"/\" std::ceil((maxinsertall-mininsert)/pas) \"\\r\"; # On affiche la progression en %, on prend l'arrondi sup\u00e9rieur pour finir \u00e0 100% et non \u00e0 99%. # Vient ensuite le retour num\u00e9rique, on calcule \u00e0 quel test on en est sur le nombre total de tests \u00e0 r\u00e9aliser en prenant en compte les pas. # On finit par un \\r pour ramener le curseur au d\u00e9but de la ligne pour pr\u00e9parer la prochaine progression. std::cout.flush(); # Emp\u00eache un retour \u00e0 la ligne automatique. La barre s'affiche ensuite comme ceci : [################################## ] 59% | 779/1337","title":"Fonctionnement"},{"location":"fonctionnement/#fonctionnement","text":"Comment le programme fonctionne \u00e9tape par \u00e9tape et les bouts de code correspondants.","title":"Fonctionnement"},{"location":"fonctionnement/#commandes-options","text":"Les options sont g\u00e9r\u00e9e gr\u00e2ce \u00e0 la librairie getopt . La commande de base est la suivante : ./hachageJV , \u00e0 laquelle s'ajoutent plusieurs options que sont les suivantes : -m [mot] - Affiche le nombre d'occurences d'un mot dans le fichier. -c - Mode de calcul des temps, sans cette option le programme se contente de remplir la table de hachage (et d'y rechercher un mot si l'option -m est utilis\u00e9e). -d - Mode d'\u00e9dition de donn\u00e9es. Active l'\u00e9criture des donn\u00e9es de temps sur un fichier .dat quand utilis\u00e9e avec l'option -c. -a [min] - Borne inf\u00e9rieure de la range de taille de table \u00e0 tester. Est fix\u00e9e \u00e0 10 par d\u00e9faut. Doit \u00eatre positive et inf\u00e9rieure \u00e0 la borne sup\u00e9rieure. -z [max] - Borne sup\u00e9rieure de la range de la taille de table \u00e0 tester. Est fix\u00e9e \u00e0 300 par d\u00e9faut. Doit \u00eatre sup\u00e9rieure \u00e0 la borne inf\u00e9rieure et inf\u00e9rieure \u00e0 13 996 (nombre de mots diff\u00e9rents dans Voyage au centre de la Terre). -i [iterations] - Nombre d'it\u00e9rations pour chaque calcul de moyenne de temps. Augmenter ce nombre donnera des r\u00e9sultats plus lisses au prix de la performance. Est fix\u00e9e \u00e0 10 par d\u00e9faut. Doit \u00eatre positive. -p [pas] - Pas pour tester chaque taille de table dans la range indiqu\u00e9e. Est fix\u00e9 \u00e0 1 par d\u00e9faut. Doit \u00eatre positif. -f [fichier] - Permet de choisir le fichier de sortie du nombre d'occurences des mots. Attention ce fichier sera \u00e9cras\u00e9 sans confirmation au d\u00e9but du programme. Est fix\u00e9 \u00e0 'occurences.txt' par d\u00e9faut.","title":"Commandes &amp; options"},{"location":"fonctionnement/#initialisation","text":"Apr\u00e8s v\u00e9rification des options et initialisation des diff\u00e9rentes variables, le programme commence par ouvrir le fichier texte pour en compter les occurences des diff\u00e9rents mots : std::ifstream ifs; # D\u00e9claration d'un flux d'entr\u00e9e. ifs.open(ficTexte,std::ifstream::in); # Ouverture du fichier texte \u00e0 analyser en lecture. Ensuite, gr\u00e2ce \u00e0 la librairie vector et pour \u00e9viter des sou\u00e7is de performance, il va nous falloir stocker tout le contenu de ce fichier texte dans une variable. Cette variable sera dans notre cas un vecteur de string (librairie cstring ) : std::vector std::string livre; # Cette d\u00e9claration est en r\u00e9alit\u00e9 faite avant mais cela aide \u00e0 la compr\u00e9hension. while(ifs mot ifs.good()) # Tant que l'on est pas arriv\u00e9 \u00e0 la fin du fichier livre.push_back(mot); # On ajoute chaque mot dans le vecteur. Une fois cela fait, le programme est pr\u00eat \u00e0 fonctionner.","title":"Initialisation"},{"location":"fonctionnement/#i-nombre-doccurences","text":"Le premier mode de fonctionnement de ce programme est le comptage du nombre d'occurences de chaque mot pr\u00e9sent dans le fichier texte et la possibilit\u00e9 de rechercher le nombre d'occurences d'un mot. Voici le fonctionnement de cette partie :","title":"I - Nombre d'occurences"},{"location":"fonctionnement/#incrementation","text":"Il nous faut pour commencer entrer tous les mots dans la table de hachage, on va faire cela en se servant du mot-cl\u00e9 auto : for (auto mot: livre) # Va parcourir tous les index du vecteur de mots. map[mot]++; # On incr\u00e9mente son nombre d'occurrence dans la table de hachage. Les avantages de cette syntaxe sont que auto est plus efficace qu'une simple boucle for en terme de m\u00e9moire, et map[mot]++; couvre aussi bien le cas o\u00f9 le mot est d\u00e9ja pr\u00e9sent dans la table que celui o\u00f9 il ne l'est pas (dans ce cas il cr\u00e9era cette cl\u00e9 et initialisera sa valeur \u00e0 1).","title":"Incr\u00e9mentation"},{"location":"fonctionnement/#recherche-dun-mot","text":"Une fois que la table de hachage est remplie, nous pouvons rechercher le nombre d'occurences d'un mot en particulier : std::unordered_map std::string, int ::const_iterator motch; motch= map.find(motcherche); # On regarde si le mot cherch\u00e9 est bien dans la table. if(motch != map.end()) # Si c'est le cas std::cout \"Nombre d'occurences du mot '\" motcherche \"' : \" map[mot] std::endl; # On affiche son nombre d'occurences. else # Sinon std::cout \"Le mot : '\" motcherche \"' ne figure pas dans le fichier.\" std::endl; # On indique qu'il ne figure pas dans la table.","title":"Recherche d'un mot"},{"location":"fonctionnement/#sortie","text":"Pour sortir tous les mots et leurs occurences, il faut d'abord vider le fichier pr\u00e9c\u00e9dent d'occurences, pour ne pas provoquer de doublons : # Cette suite dop\u00e9rations est en r\u00e9alit\u00e9 effectu\u00e9e plus t\u00f4t dans l'\u00e9xecution mais cela aide \u00e0 la compr\u00e9hension. std::ofstream ofs; # On cr\u00e9e le flux de sortie. std::cout \"R\u00e9initialisation du fichier d'occurences...\" std::endl; # Pour savoir que la proc\u00e9dure \u00e0 commenc\u00e9e. if( remove(writefic.c_str()) != 0 ) # Suppression du fichier. perror( \"Echec de l'op\u00e9ration :/ \" ); # Erreur else puts( \"Fichier r\u00e9initialis\u00e9 avec succ\u00e8s !\" ); # Succ\u00e8s ofs.open(writefic, std::ofstream::out); # On r\u00e9ouvre le fichier en lecture, ce qui \u00e0 pour effet de le recr\u00e9er. Ensuite, il faut bien \u00e9videmment le remplir : for (auto x: map) # Nouvelle utilisation de auto pour parcourir la table de hachage. ofs x.first \": \" x.second std::endl; # On \u00e9crit chaque mot (cl\u00e9) avec son nombre d'occurences (valeur) dans le fichier.","title":"Sortie"},{"location":"fonctionnement/#ii-calcul-de-la-complexite","text":"Le second mode d'utilisation de ce programme est celui qui nous int\u00e9rresse le plus : les temps d'insertion et de recherche. Voici comment tout cela fonctionne :","title":"II - Calcul de la complexit\u00e9"},{"location":"fonctionnement/#tailles-de-la-table","text":"Le but de ce programme est de pouvoir observer la complexit\u00e9 des temps d'insertion et de recherche, donc de mesurer ces temps pour des tailles de table de hachage variables. Pour ce faire on va dans un premier temps remplir la table jusqu'a la taille minimale de la range entr\u00e9e en param\u00e8tre : while(map.size() mininsert map.size() livre.size()){ # Tant que la taille de la table est inf\u00e9rieure \u00e0 la taille souhait\u00e9e et qu'on a pas entr\u00e9 tout le livre. int chosen = std::rand() % livre.size(); # On tire un chiffre al\u00e9atoire en tre 0 et le nombre de mots du livre. mot = livre[chosen]; # Cela nous donne un mot. map[mot]++; # On ajoute ce mot / incr\u00e9mente son nombre d'occurences. } Ensuite, un fois notre table de hachage initialis\u00e9e \u00e0 la taille minimale voulue, on rentre dans la boucle \"principale\" qui va pour chaque taille de la table voulue dans la range entr\u00e9e en param\u00e8tre (en prenant le pas en compte) calculer le temps d'insertion, le temps de recherche, le taux de charge et \u00e9crire ces valeurs dans le fichier de sortie : for(uint w=mininsert;w =maxinsertall;w=w+pas){ # On va parcourir la range de taille de table voulue en prenant le pas entr\u00e9 en param\u00e8tre comme pas. while(map.size() w map.size() livre.size()){ # On ajuste la taille de la table si n\u00e9cessaire (si pas 1). int chosen = std::rand() % livre.size(); mot = livre[chosen]; map[mot]++; } # Les calculs sont faits i\u00e7i... # Sortie... } Un fois cette boucle r\u00e9alis\u00e9e, nous pouvons nous pencher sur le reste.","title":"Tailles de la table"},{"location":"fonctionnement/#temps-de-recherche","text":"Le temps de recherche est calcul\u00e9 avant le temps d'insertion, pour ce faire on va simplement s\u00e9lectionner un mot au hasard dans le livre : int chosen = (std::rand() % livre.size()); # Un index de mot au hasard dans le livre. mot = livre[chosen]; # On extrait le mot s\u00e9lectionn\u00e9. Cela nous permet de pouvoir piocher aussi boen un mot qui existe d\u00e9ja dans la table comme un qui n'y figure pas (pour avoir des r\u00e9sultats refl\u00e9tant la r\u00e9alit\u00e9). On a plus qu'a rechercher ce mot dans la table. cette recherche est effectu\u00e9e gr\u00e2ce \u00e0 la fonction find() de unordered_map . Qui renvoie l'index du mot recherch\u00e9 dans la table si il s'y trouve, et std::unordered_map::end sinon. On initialise donc une variable pour pouvoir stocker ce r\u00e9sultat, bien qu'on ne s'en serve pas par la suite : std::unordered_map std::string, int ::const_iterator found; # Initialisation du conteneur de la sortie du find(). Enfin, pour calculer le temps pris pour cette recherche, nous nous servons de la librairie chrono gr\u00e2ce \u00e0 laquelle nous allons cr\u00e9er 2 time points en nanosecondes : le premier juste avant la recherche et le second juste apr\u00e8s. Nous pouvons ensuite r\u00e9cup\u00e9rer le temps pris pour la recherche gr\u00e2ce \u00e0 la diff\u00e9rence de ces deux time points : std::chrono::steady_clock::time_point debfind = std::chrono::steady_clock::now(); # Premier time point T1. found = map.find(mot); # On recherche le mot. std::chrono::steady_clock::time_point endfind = std::chrono::steady_clock::now(); # Second time point T2. std::chrono::nanoseconds time_find = std::chrono::duration_cast std::chrono::nanoseconds (endfind - debfind); # T2 - T1 pour avoir la dur\u00e9e de la recherche. On r\u00e9cup\u00e8re donc le temps pris par la recherche dans la variable time_find , en nanosecondes.","title":"Temps de recherche"},{"location":"fonctionnement/#temps-dinsertion","text":"Comme pour la recherche, le temps d'insertion d\u00e9but par le choix d'un mot au hasard dans le livre : int chosen = (std::rand() % livre.size()); # Un index de mot au hasard dans le livre. mot = livre[chosen]; # On extrait le mot s\u00e9lectionn\u00e9. Ensuite on ins\u00e8re le mot dans la table et on chronom\u00e8tre le temps pris pour cette insertion comme pour le temps de la recherche, gr\u00e2ce \u00e0 2 time points avant et apr\u00e8s l'insertion : std::chrono::steady_clock::time_point debinsert = std::chrono::steady_clock::now(); # T1 newmap[mot]++; # Insertion std::chrono::steady_clock::time_point endinsert = std::chrono::steady_clock::now(); # T2 std::chrono::nanoseconds time_insert = std::chrono::duration_cast std::chrono::nanoseconds (endinsert - debinsert); # T2 - T1","title":"Temps d'insertion"},{"location":"fonctionnement/#taux-de-charge","text":"La mesure du taux de charge est tr\u00e8s importante car elle permet de voir quand la table devient satur\u00e9e et quand les collisions ont le plus de chances d'arriver (cf : Load Factor ). Le Taux de charge est calcul\u00e9 en divisant la taille de la table par le nombre de cl\u00e9s ayant au moins une valeur associ\u00e9e Ce taux de charge est r\u00e9cup\u00e9r\u00e9 gr\u00e2ce \u00e0 la fonction suivante : float tauxCharge = map.load_factor(); # Renvoie un float entre 0 et 1 qui correpond au taux de charge.","title":"Taux de charge"},{"location":"fonctionnement/#moyennes","text":"Pour avoir des r\u00e9sultats plus lisses et pour \u00e9viter les erreurs occasionnelles qui pourraient provoquer des pics sur le graphe, on va donc r\u00e9aliser plusieurs fois chaque recherche et chaque insertion et en faire les moyennes. Chaque recherche et chaque insertion sera faite avec des mots diff\u00e9rents car ce n'est pas l'insertion ou la recherche d'un mot en particulier mais bien le comportement de la table pour une taille donn\u00e9e. Pour ce faire on va avoir besoin de 2 vecteurs (librairie vector ) de std::chrono::nanoseconds dans lesquels nous allons stocker respectivement nos temps d'insertion et de recherche. On commence par les initialiser : std::vector std::chrono::nanoseconds tabtempsinsert; # Vecteur des temps d'insertion std::vector std::chrono::nanoseconds tabtempsfind; # Vecteur des temps de recherche Ensuite, il va nous falloir r\u00e9aliser chaque op\u00e9rations plusieurs fois. Ce nombre de fois est param\u00e9tr\u00e9 par l'utilisateur et est stock\u00e9 dans un uint nomm\u00e9 iterations . Exemple pour la recherche : tabtempsfind.clear(); # On vide le vecteur qui a pu \u00eatre rempli par les it\u00e9rations pr\u00e9c\u00e9dentes. for(uint i=1;i =iterations;++i){ # Pour le nombre d'it\u00e9rations d\u00e9fini. # Proc\u00e9dure de recherche et mesure du temps pris... tabtempsfind.push_back(time_find); # On ajoute le temps trouv\u00e9 au vecteur correspondant. } On va ensuite faire la somme de tous les temps contenus dans le vecteur. Par gain de temps et pour nous \u00e9viter des casts \u00e9vitables, on stockera ce temps dans la m\u00eame variable que celle ayant servi \u00e0 mesurer le temps juste avant : time_find = std::chrono::nanoseconds::zero(); # On remet le temps \u00e0 0. for(auto n : tabtempsfind) # Pour chaque index du vecteur. time_find += n; # On incr\u00e9mente la variable de ce temps. Pour avoir une moyenne il nous faut ensuite diviser cette somme par le nombre de temps qu'elle contient, rien de plus simple : double totimefind = time_find.count() / (double)tabtempsfind.size(); # .count() permet de r\u00e9cup\u00e9rer une valeur num\u00e9rique du temps. # Le cast est n\u00e9c\u00e9ssaire pour une division. On r\u00e9cup\u00e8re donc la moyenne des temps de recherche dnas la variable totimefind . (Oui bon j'aurais pu trouver mieux comme nom je sais) Le cas de l'insertion est tr\u00e8s l\u00e9g\u00e9remment diff\u00e9rent, bien que son d\u00e9but soit identique \u00e0 celui de la recherche : tabtempsinsert.clear(); # On vide le vecteur for(uint i=1;i =iterations;++i){ # Pour chaque it\u00e9ration. int chosen = (std::rand() % livre.size()); # On choisit un mot... mot = livre[chosen]; On ne pourra pas simplement ins\u00e9rer plusieurs mots \u00e0 la suite et compter le temps, car la taille de la table va \u00e9voluer sans que l'on le veuille. Pour pallier \u00e0 ce souci, on va devoir pour chaque it\u00e9ration cr\u00e9er une copie de la table de hachage : std::unordered_map std::string, int newmap(map); # Constructeur par copie. La suite est identique \u00e0 la proc\u00e9dure de calcul de temps d'insertion expliqu\u00e9e plus haut \u00e0 cela pr\u00e8s qu'au lieu d'ins\u00e9rer le mot dans la table on l'ins\u00e8re dans la copie de la table : # Time point 1 newmap[mot]++; # Insertion # Time point 2 # time_insert = T2 - T1 tabtempsinsert.push_back(time_insert); # Ajout du temps au vecteur des temps d'insertion. La suite est identique \u00e0 la recherche, en changeant de vecteur utilis\u00e9 evidemment : time_insert = std::chrono::nanoseconds::zero(); # On remet le temps \u00e0 0. for(auto n : tabtempsinsert) #Pour chaque temps dans le vecteur. time_insert += n; #On incr\u00e9mente la variable de ce temps. double totimeinsert = time_insert.count() / (double)tabtempsinsert.size(); # On en fait ensuite la moyenne. On r\u00e9cup\u00e8re la moyenne des temps d'insertion dans la variable totimeinsert .","title":"Moyennes"},{"location":"fonctionnement/#sortie_1","text":"La sortie se fait dans un fichier data.dat unique constitu\u00e9 de la sorte : Taille table Temps Insertion Temps Recherche Taux de charge 0 2.69e-06 4.20e-07 0.001337 1 1.337e-05 3.86e-06 0.0713705 2 ... ... ... Le fichier \u00e0 \u00e9t\u00e9 initialis\u00e9 comme l'a \u00e9t\u00e9 celui du nombre d'occurences (expliqu\u00e9 plus haut), et est donc vide au d\u00e9but de l'\u00e9criture. Pour \u00e9crire dedans on va simplement s\u00e9parer toutes les donn\u00e9es par un espace : ficall map.size()-1 \" \" totimeinsert/100000000 \" \" totimefind/100000000 \" \" map.load_factor() std::endl; # On divise tous les temps par 100 000 000 pour avoir des secondes. Vous pouvez t\u00e9l\u00e9charger un fichier de donn\u00e9es en cliquant ici","title":"Sortie"},{"location":"fonctionnement/#barre-de-progression","text":"Pour se rendre compte de la progression du programme, car son utilisation peut prendre beaucoup de temps, j'ai r\u00e9alis\u00e9 une barre de progression. Elle suit les tailles de table test\u00e9es, on ne sait pas pr\u00e9cisemment \u00e0 quelle it\u00e9ration on en est (pour les moyennes) mais on sait quelle taille de table est test\u00e9e. Voici son fonctionnement : On commence par trouver le pourcentage de progression actuel, qui est pris en utilisant la position actuelle de la boucle ( w ) et en la comparant avec son maximum ( maxinsertall ), auquel on soustrait le point de d\u00e9part ( mininsert ) car sinon une \u00e9tude sur des tailles allant par exemple de 5000 \u00e0 10 000 commen\u00e7erait \u00e0 50% d\u00e8s le d\u00e9but. float progress = (float)(w-mininsert)/(maxinsertall-mininsert); # Progression en pourcentage. int pos = 60 * progress; # On le multiplie par 60 (taille arbitraire de la barre en caract\u00e8res). Vient ensuite la barre en elle-m\u00eame : std::cout \"[\"; # Le cot\u00e9 gauche de la barre, fixe. for (int k = 0; k 60; ++k) { # Pour toute la longueur de la barre. if (k pos) std::cout \"#\"; # Si on est avant la position de la progression, on affiche un \"#\". else if (k == pos) std::cout \" \"; # Si on est exactement \u00e0 cette position, on affiche un \" \". else std::cout \" \"; # Et sinon on affiche un espace (barre vide). } std::cout \"] \" std::ceil(progress * 100.0) \" % | \" std::ceil((w-mininsert)/pas) \"/\" std::ceil((maxinsertall-mininsert)/pas) \"\\r\"; # On affiche la progression en %, on prend l'arrondi sup\u00e9rieur pour finir \u00e0 100% et non \u00e0 99%. # Vient ensuite le retour num\u00e9rique, on calcule \u00e0 quel test on en est sur le nombre total de tests \u00e0 r\u00e9aliser en prenant en compte les pas. # On finit par un \\r pour ramener le curseur au d\u00e9but de la ligne pour pr\u00e9parer la prochaine progression. std::cout.flush(); # Emp\u00eache un retour \u00e0 la ligne automatique. La barre s'affiche ensuite comme ceci : [################################## ] 59% | 779/1337","title":"Barre de progression"},{"location":"resultats/","text":"R\u00e9sultats Les r\u00e9sultats obtenus par le programme, expliqu\u00e9s par des graphiques. Th\u00e9orique Les r\u00e9sultats th\u00e9oriques devraient \u00eatre les suivants, l'avantage de la table de hachage est de tr\u00e8s bien fonctionner m\u00eame avec une grande taille. Les complexit\u00e9s attendues sont de l'ordre de O(1) pour l'insertion et pour la recherche. Car la table passe par des hash et n'a donc pas besoin de parcourir toute la table pour savoir si une cl\u00e9 se trouve dedans ou non. Pratique Les r\u00e9sultats pratiquent corroborent avec les hypoth\u00e8ses \u00e9mises plus haut, on \u00e0 une insertion et une recherche de l'ordre de O(1) . Taille de 0 \u00e0 13996 mots avec des moyennes de 200 it\u00e9rations On remarque cependant des pics tr\u00e8s nets lors de certaines insertions, qui correspondent \u00e0 la r\u00e9allocation de la table lorsque cette derni\u00e8re devient trop petite. Ces pics co\u00efncident avec les chutes de taux de charge de la table, sans surprise. L\u00e0 ou je suis plus surpris, c'est en faisant varier le nombre d'it\u00e9rations pour les moyennes, l\u00e0 ou on devrait trouver des r\u00e9sultats plus disparates, moins lisses, le r\u00e9sultat th\u00e9oriquement 20 fois moins \"lisse\" que le pr\u00e9c\u00e9dent l'est presque autant : Taille de 0 \u00e0 13996 mots avec des moyennes de 10 it\u00e9rations Tous les graphiques graphiques sont obtenus gr\u00e2ce \u00e0 gnuplot","title":"R\u00e9sultats"},{"location":"resultats/#resultats","text":"Les r\u00e9sultats obtenus par le programme, expliqu\u00e9s par des graphiques.","title":"R\u00e9sultats"},{"location":"resultats/#theorique","text":"Les r\u00e9sultats th\u00e9oriques devraient \u00eatre les suivants, l'avantage de la table de hachage est de tr\u00e8s bien fonctionner m\u00eame avec une grande taille. Les complexit\u00e9s attendues sont de l'ordre de O(1) pour l'insertion et pour la recherche. Car la table passe par des hash et n'a donc pas besoin de parcourir toute la table pour savoir si une cl\u00e9 se trouve dedans ou non.","title":"Th\u00e9orique"},{"location":"resultats/#pratique","text":"Les r\u00e9sultats pratiquent corroborent avec les hypoth\u00e8ses \u00e9mises plus haut, on \u00e0 une insertion et une recherche de l'ordre de O(1) . Taille de 0 \u00e0 13996 mots avec des moyennes de 200 it\u00e9rations On remarque cependant des pics tr\u00e8s nets lors de certaines insertions, qui correspondent \u00e0 la r\u00e9allocation de la table lorsque cette derni\u00e8re devient trop petite. Ces pics co\u00efncident avec les chutes de taux de charge de la table, sans surprise. L\u00e0 ou je suis plus surpris, c'est en faisant varier le nombre d'it\u00e9rations pour les moyennes, l\u00e0 ou on devrait trouver des r\u00e9sultats plus disparates, moins lisses, le r\u00e9sultat th\u00e9oriquement 20 fois moins \"lisse\" que le pr\u00e9c\u00e9dent l'est presque autant : Taille de 0 \u00e0 13996 mots avec des moyennes de 10 it\u00e9rations Tous les graphiques graphiques sont obtenus gr\u00e2ce \u00e0 gnuplot","title":"Pratique"}]}